---
title: "任务 B 代码解读：Market Decoder"
date: "2026-01-26"
description: "任务 B 源码逐段解读与数据流说明。"
tags: ["Blog"]
published: true
---


# 任务 B 代码解读：Market Decoder

本文件逐段解读市场参数解码的实现，结合 Gamma API 与链上日志两条数据源，说明各函数的角色与数据流。

## 文件与结构

- `src/market_decoder.py`：主逻辑与 CLI 入口。
- `src/ctf/derive.py`：CTF 公式计算集合/头寸 ID。
- `src/indexer/gamma.py`：Gamma API 请求封装。
- `src/utils.py`：输出工具。

## 关键逻辑拆解

### ConditionPreparation 解析

- `CONDITION_PREPARATION_SIGNATURES`：兼容两种 ABI 顺序。
- `decode_condition_preparation(log)`：
  - 读取 `topics` 与 `data`。
  - `outcomeSlotCount` 从 data 解码。
  - 通过 `_topic_is_address` 判断 topics[1] 是否为地址，从而区分字段顺序。
  - 返回规范化字典 `{conditionId, oracle, questionId, outcomeSlotCount}`。

### Gamma API 数据抽取

在 `market_decoder.py` 中：

- `_resolve_market_from_slug(slug)`：
  - 先尝试 `fetch_market_by_slug`。
  - 不存在则尝试 `fetch_event_by_slug` 获取事件，随后 `fetch_markets_for_event` 获取市场列表。
  - 使用 `_extract_market_fields` 统一字段命名。
- `_extract_market_fields`：
  - 兼容多种字段命名（`conditionId`/`condition_id`/`conditionIdHex` 等）。
  - `clobTokenIds` 支持字符串 JSON 解析。

### 参数合并策略

`decode_market` 中的字段来源优先级：

1. **链上日志**优先（如果提供 `tx_hash`）。
2. **Gamma API**补全缺失字段。
3. 仍缺 `oracle` 时，使用 `get_oracle_address()`。

缺 `conditionId` 或 `questionId` 会抛错，确保计算可进行。

### TokenId 计算实现

`src/ctf/derive.py`：

- `_normalize_bytes32` 把 `condition_id` 等参数规范化为 32 字节。
- `derive_binary_positions`：
  - `collection_yes = keccak256(parentCollectionId, conditionId, 1)`
  - `collection_no = keccak256(parentCollectionId, conditionId, 2)`
  - `position_yes = keccak256(collateralToken, collection_yes)`
  - `position_no = keccak256(collateralToken, collection_no)`
- 返回 `BinaryPositions`，最终映射为 `yesTokenId` / `noTokenId`。

## 数据输出

`decode_market` 构建 payload：

- 主字段：`conditionId`、`oracle`、`questionId`、`outcomeSlotCount`、`collateralToken`、`yesTokenId`、`noTokenId`。
- 若有 Gamma 数据，附加 `gamma` 字段，用于与 `clobTokenIds` 交叉验证。

## 可关注的细节

- `_topic_is_address` 用 32 字节 topic 中前 12 字节全 0 判断地址类型。
- `questionId` 与 `conditionId` 采用 bytes32 的字符串形式，未直接转换为十六进制字节数组，计算时由 `derive_binary_positions` 统一规范化。
- `USDC_E` 为常量抵押品地址，简化了输入依赖。


## Source Code (verbatim)

```python
from __future__ import annotations

import argparse
import json
from typing import Any, Dict, Optional

from eth_abi import decode
from hexbytes import HexBytes
from web3 import Web3

from src.config import USDC_E, get_oracle_address, get_rpc_url
from src.ctf.derive import derive_binary_positions
from src.indexer.gamma import fetch_event_by_slug, fetch_market_by_slug, fetch_markets_for_event
from src.utils import normalize_address, print_json, write_json


CONDITION_PREPARATION_SIGNATURES = {
    Web3.keccak(text="ConditionPreparation(bytes32,address,bytes32,uint256)").hex(),
    Web3.keccak(text="ConditionPreparation(address,bytes32,uint256,bytes32)").hex(),
}


def _as_hex(value: Any) -> str:
    if isinstance(value, HexBytes):
        return value.hex()
    return str(value)


def _topic_to_address(topic: str) -> str:
    if topic.startswith("0x"):
        topic = topic[2:]
    return "0x" + topic[-40:]


def _topic_is_address(topic: str) -> bool:
    if not topic.startswith("0x") or len(topic) != 66:
        return False
    return topic[2:26] == "0" * 24


def decode_condition_preparation(log: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    topics = [_as_hex(topic) for topic in log.get("topics", [])]
    if len(topics) < 4:
        return None

    signature = topics[0]
    if signature not in CONDITION_PREPARATION_SIGNATURES:
        return None

    data_hex = log.get("data", "0x")
    data_bytes = bytes.fromhex(data_hex[2:]) if data_hex.startswith("0x") else bytes.fromhex(data_hex)
    if len(data_bytes) < 32:
        return None

    outcome_slot_count = int(decode(["uint256"], data_bytes)[0])

    if _topic_is_address(topics[1]):
        oracle = _topic_to_address(topics[1])
        question_id = topics[2]
        condition_id = topics[3]
    else:
        condition_id = topics[1]
        oracle = _topic_to_address(topics[2])
        question_id = topics[3]

    return {
        "conditionId": condition_id,
        "oracle": Web3.to_checksum_address(oracle),
        "questionId": question_id,
        "outcomeSlotCount": outcome_slot_count,
    }


def _extract_nested_id(value: Any) -> Optional[str]:
    if isinstance(value, dict):
        return value.get("id") or value.get("address") or value.get("value")
    return value


def _parse_list_field(value: Any) -> Any:
    if isinstance(value, str):
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            return value
    return value


def _extract_market_fields(market: Dict[str, Any]) -> Dict[str, Any]:
    condition_id = _extract_nested_id(
        market.get("conditionId")
        or market.get("condition_id")
        or market.get("condition")
        or market.get("conditionIdHex")
    )
    question_id = _extract_nested_id(
        market.get("questionId")
        or market.get("questionID")
        or market.get("question_id")
        or market.get("question")
        or market.get("questionIdHex")
    )
    oracle = _extract_nested_id(
        market.get("oracle")
        or market.get("oracleAddress")
        or market.get("oracle_address")
        or market.get("oracleAddressHex")
    )
    clob_token_ids = _parse_list_field(market.get("clobTokenIds") or market.get("clob_token_ids") or [])

    return {
        "conditionId": condition_id,
        "questionId": question_id,
        "oracle": oracle,
        "clobTokenIds": clob_token_ids,
        "raw": market,
    }


def _resolve_market_from_slug(slug: str) -> Optional[Dict[str, Any]]:
    market = fetch_market_by_slug(slug)
    if market:
        return _extract_market_fields(market)

    event = fetch_event_by_slug(slug)
    if not event:
        return None

    event_id = event.get("id") or event.get("eventId") or event.get("event_id")
    if not event_id:
        return None

    markets = fetch_markets_for_event(str(event_id))
    if not markets:
        return None

    candidates = [_extract_market_fields(market) for market in markets]
    for candidate in candidates:
        if candidate.get("conditionId") and candidate.get("questionId") and candidate.get("oracle"):
            return candidate

    return candidates[0] if candidates else None


def decode_market(
    *,
    tx_hash: Optional[str],
    log_index: Optional[int],
    market_slug: Optional[str],
) -> Dict[str, Any]:
    gamma_data: Optional[Dict[str, Any]] = None
    condition_data: Optional[Dict[str, Any]] = None

    if market_slug:
        gamma_data = _resolve_market_from_slug(market_slug)
        if not gamma_data:
            raise RuntimeError(f"No market found for slug: {market_slug}")

    if tx_hash:
        w3 = Web3(Web3.HTTPProvider(get_rpc_url()))
        receipt = w3.eth.get_transaction_receipt(tx_hash)
        for log in receipt["logs"]:
            if log_index is not None and int(log["logIndex"]) != log_index:
                continue
            decoded = decode_condition_preparation(log)
            if decoded:
                condition_data = decoded
                break

        if not condition_data:
            raise RuntimeError("ConditionPreparation log not found in transaction receipt.")

    condition_id = None
    question_id = None
    oracle = None
    outcome_slot_count = 2

    if condition_data:
        condition_id = condition_data.get("conditionId")
        question_id = condition_data.get("questionId")
        oracle = condition_data.get("oracle")
        outcome_slot_count = int(condition_data.get("outcomeSlotCount", 2))

    if gamma_data:
        condition_id = condition_id or gamma_data.get("conditionId")
        question_id = question_id or gamma_data.get("questionId")
        oracle = oracle or gamma_data.get("oracle")

    if not oracle:
        oracle = get_oracle_address()

    if not condition_id or not question_id:
        missing = [name for name, value in [("conditionId", condition_id), ("questionId", question_id)] if not value]
        raise RuntimeError(
            "Missing condition data (" + ", ".join(missing) + "). Provide --market-slug or a tx hash with ConditionPreparation log."
        )

    positions = derive_binary_positions(
        oracle=oracle,
        question_id=question_id,
        condition_id=condition_id,
        collateral_token=USDC_E,
    )

    payload: Dict[str, Any] = {
        "conditionId": condition_id,
        "oracle": Web3.to_checksum_address(oracle),
        "questionId": question_id,
        "outcomeSlotCount": outcome_slot_count,
        "collateralToken": USDC_E,
        "yesTokenId": positions.position_yes,
        "noTokenId": positions.position_no,
    }

    if gamma_data:
        payload["gamma"] = {
            "conditionId": gamma_data.get("conditionId"),
            "oracle": gamma_data.get("oracle"),
            "questionId": gamma_data.get("questionId"),
            "clobTokenIds": gamma_data.get("clobTokenIds"),
            "raw": gamma_data.get("raw"),
        }

    return payload


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Decode Polymarket market parameters.")
    parser.add_argument("--market-slug", help="Gamma API market slug")
    parser.add_argument("--tx-hash", help="Transaction hash with ConditionPreparation")
    parser.add_argument("--log-index", type=int, help="Log index of ConditionPreparation")
    parser.add_argument("--output", help="Write JSON output to a file")
    return parser.parse_args()


def main() -> None:
    args = _parse_args()
    payload = decode_market(tx_hash=args.tx_hash, log_index=args.log_index, market_slug=args.market_slug)

    if args.output:
        write_json(args.output, payload)
    else:
        print_json(payload)


if __name__ == "__main__":
    main()
```

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Any

from hexbytes import HexBytes
from web3 import Web3


@dataclass(frozen=True)
class BinaryPositions:
    collection_yes: str
    collection_no: str
    position_yes: str
    position_no: str


def _normalize_bytes32(value: Any) -> bytes:
    if isinstance(value, (bytes, bytearray, HexBytes)):
        data = bytes(value)
        if len(data) != 32:
            raise ValueError("Expected 32-byte value.")
        return data
    if isinstance(value, int):
        return value.to_bytes(32, byteorder="big")
    if isinstance(value, str):
        hex_value = value
        if not hex_value.startswith("0x"):
            hex_value = "0x" + hex_value
        data = Web3.to_bytes(hexstr=hex_value)
        if len(data) != 32:
            raise ValueError("Expected 32-byte hex string.")
        return data
    raise TypeError("Unsupported bytes32 value type.")


def derive_binary_positions(
    *,
    oracle: str,
    question_id: str,
    condition_id: str,
    collateral_token: str,
) -> BinaryPositions:
    w3 = Web3()
    parent_collection_id = _normalize_bytes32("0x" + "00" * 32)
    condition_id_bytes = _normalize_bytes32(condition_id)

    collection_yes = w3.solidity_keccak(
        ["bytes32", "bytes32", "uint256"],
        [parent_collection_id, condition_id_bytes, 1],
    ).hex()
    collection_no = w3.solidity_keccak(
        ["bytes32", "bytes32", "uint256"],
        [parent_collection_id, condition_id_bytes, 2],
    ).hex()

    position_yes = w3.solidity_keccak(
        ["address", "bytes32"],
        [Web3.to_checksum_address(collateral_token), _normalize_bytes32(collection_yes)],
    ).hex()
    position_no = w3.solidity_keccak(
        ["address", "bytes32"],
        [Web3.to_checksum_address(collateral_token), _normalize_bytes32(collection_no)],
    ).hex()

    return BinaryPositions(
        collection_yes=collection_yes,
        collection_no=collection_no,
        position_yes=position_yes,
        position_no=position_no,
    )
```

```python
from __future__ import annotations

from typing import Any, Dict, List, Optional

import requests

from src.config import get_gamma_api_url


def _get_json(path: str, params: Optional[Dict[str, str]] = None) -> Any:
    base_url = get_gamma_api_url().rstrip("/")
    url = f"{base_url}{path}"
    response = requests.get(url, params=params, timeout=30)
    response.raise_for_status()
    return response.json()


def fetch_event_by_slug(slug: str) -> Optional[Dict[str, Any]]:
    payload = _get_json("/events", params={"slug": slug})
    if isinstance(payload, list):
        return payload[0] if payload else None
    return payload


def fetch_market_by_slug(slug: str) -> Optional[Dict[str, Any]]:
    payload = _get_json("/markets", params={"slug": slug})
    if isinstance(payload, list):
        return payload[0] if payload else None
    return payload


def fetch_markets_for_event(event_id: str) -> List[Dict[str, Any]]:
    payload = _get_json("/markets", params={"event": event_id})
    if isinstance(payload, list):
        return payload
    return [payload]
```
