---
title: "任务 B 实现说明：Market Decoder"
date: "2026-01-26"
description: "任务 B 的实现流程、关键逻辑与参数解码说明。"
tags: ["Blog"]
published: true
---


# 任务 B 实现说明：Market Decoder

本文件解释任务 B（市场参数解码器）的实际实现，依据现有代码 `src/market_decoder.py`、`src/ctf/derive.py` 与 `src/indexer/gamma.py` 进行说明。

## 目标与输入输出

- 目标：给定市场创建日志或市场 slug，计算链上市场核心参数，尤其是 `yesTokenId` 与 `noTokenId`。
- 输入（任选其一或组合）：
  - `--market-slug <slug>`（Gamma API）
  - `--tx-hash <hash>` + `--log-index <index>`（链上日志）
- 输出：包含 `conditionId`、`oracle`、`questionId`、`outcomeSlotCount`、`collateralToken`、`yesTokenId`、`noTokenId`，可选 `gamma` 字段。

## 实现流程

1. 解析 Gamma API 数据（可选）
   - `fetch_market_by_slug` 查询市场。
   - 若未命中，则 `fetch_event_by_slug` 查事件，再 `fetch_markets_for_event` 获取事件下市场。
   - `_extract_market_fields` 统一提取 `conditionId`、`questionId`、`oracle` 与 `clobTokenIds`。

2. 解析链上 ConditionPreparation（可选）
   - `decode_condition_preparation` 支持两个签名版本（`CONDITION_PREPARATION_SIGNATURES`）。
   - 从 topics/data 解析出 `conditionId`、`oracle`、`questionId`、`outcomeSlotCount`。

3. 组装基础参数
   - 优先使用链上日志，其次回退到 Gamma API。
   - 若缺失 `oracle`，使用 `get_oracle_address()` 的默认配置。
   - 若缺失 `conditionId` 或 `questionId`，直接报错，提示需提供 slug 或链上日志。

4. 计算 TokenId
   - 调用 `derive_binary_positions` 计算：
     - `collection_yes` / `collection_no`
     - `position_yes` / `position_no`（即 `yesTokenId` / `noTokenId`）
   - 抵押品统一使用 `USDC_E` 常量。

5. 输出结果
   - 结果 JSON 包含链上计算结果。
   - 若存在 Gamma 数据，附加 `gamma` 字段用于交叉验证。

## 关键细节与边界

- 事件签名兼容：`CONDITION_PREPARATION_SIGNATURES` 支持不同参数顺序的日志。
- topics 解码：通过 `_topic_is_address` 判断第一组 topic 是否为地址，从而确定字段位置。
- 数据一致性：允许 “链上日志 + Gamma 数据” 混合补全，优先链上结果。
- TokenId 计算：严格按 CTF 公式 `keccak256(collateralToken, collectionId)`。

## 关联文件

- `src/market_decoder.py`：入口与解析逻辑。
- `src/ctf/derive.py`：集合与头寸 ID 计算。
- `src/indexer/gamma.py`：Gamma API 请求封装。
- `src/config.py`：`USDC_E` 与默认 Oracle 配置。


## Source Code (verbatim)

```python
from __future__ import annotations

import argparse
import json
from typing import Any, Dict, Optional

from eth_abi import decode
from hexbytes import HexBytes
from web3 import Web3

from src.config import USDC_E, get_oracle_address, get_rpc_url
from src.ctf.derive import derive_binary_positions
from src.indexer.gamma import fetch_event_by_slug, fetch_market_by_slug, fetch_markets_for_event
from src.utils import normalize_address, print_json, write_json


CONDITION_PREPARATION_SIGNATURES = {
    Web3.keccak(text="ConditionPreparation(bytes32,address,bytes32,uint256)").hex(),
    Web3.keccak(text="ConditionPreparation(address,bytes32,uint256,bytes32)").hex(),
}


def _as_hex(value: Any) -> str:
    if isinstance(value, HexBytes):
        return value.hex()
    return str(value)


def _topic_to_address(topic: str) -> str:
    if topic.startswith("0x"):
        topic = topic[2:]
    return "0x" + topic[-40:]


def _topic_is_address(topic: str) -> bool:
    if not topic.startswith("0x") or len(topic) != 66:
        return False
    return topic[2:26] == "0" * 24


def decode_condition_preparation(log: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    topics = [_as_hex(topic) for topic in log.get("topics", [])]
    if len(topics) < 4:
        return None

    signature = topics[0]
    if signature not in CONDITION_PREPARATION_SIGNATURES:
        return None

    data_hex = log.get("data", "0x")
    data_bytes = bytes.fromhex(data_hex[2:]) if data_hex.startswith("0x") else bytes.fromhex(data_hex)
    if len(data_bytes) < 32:
        return None

    outcome_slot_count = int(decode(["uint256"], data_bytes)[0])

    if _topic_is_address(topics[1]):
        oracle = _topic_to_address(topics[1])
        question_id = topics[2]
        condition_id = topics[3]
    else:
        condition_id = topics[1]
        oracle = _topic_to_address(topics[2])
        question_id = topics[3]

    return {
        "conditionId": condition_id,
        "oracle": Web3.to_checksum_address(oracle),
        "questionId": question_id,
        "outcomeSlotCount": outcome_slot_count,
    }


def _extract_nested_id(value: Any) -> Optional[str]:
    if isinstance(value, dict):
        return value.get("id") or value.get("address") or value.get("value")
    return value


def _parse_list_field(value: Any) -> Any:
    if isinstance(value, str):
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            return value
    return value


def _extract_market_fields(market: Dict[str, Any]) -> Dict[str, Any]:
    condition_id = _extract_nested_id(
        market.get("conditionId")
        or market.get("condition_id")
        or market.get("condition")
        or market.get("conditionIdHex")
    )
    question_id = _extract_nested_id(
        market.get("questionId")
        or market.get("questionID")
        or market.get("question_id")
        or market.get("question")
        or market.get("questionIdHex")
    )
    oracle = _extract_nested_id(
        market.get("oracle")
        or market.get("oracleAddress")
        or market.get("oracle_address")
        or market.get("oracleAddressHex")
    )
    clob_token_ids = _parse_list_field(market.get("clobTokenIds") or market.get("clob_token_ids") or [])

    return {
        "conditionId": condition_id,
        "questionId": question_id,
        "oracle": oracle,
        "clobTokenIds": clob_token_ids,
        "raw": market,
    }


def _resolve_market_from_slug(slug: str) -> Optional[Dict[str, Any]]:
    market = fetch_market_by_slug(slug)
    if market:
        return _extract_market_fields(market)

    event = fetch_event_by_slug(slug)
    if not event:
        return None

    event_id = event.get("id") or event.get("eventId") or event.get("event_id")
    if not event_id:
        return None

    markets = fetch_markets_for_event(str(event_id))
    if not markets:
        return None

    candidates = [_extract_market_fields(market) for market in markets]
    for candidate in candidates:
        if candidate.get("conditionId") and candidate.get("questionId") and candidate.get("oracle"):
            return candidate

    return candidates[0] if candidates else None


def decode_market(
    *,
    tx_hash: Optional[str],
    log_index: Optional[int],
    market_slug: Optional[str],
) -> Dict[str, Any]:
    gamma_data: Optional[Dict[str, Any]] = None
    condition_data: Optional[Dict[str, Any]] = None

    if market_slug:
        gamma_data = _resolve_market_from_slug(market_slug)
        if not gamma_data:
            raise RuntimeError(f"No market found for slug: {market_slug}")

    if tx_hash:
        w3 = Web3(Web3.HTTPProvider(get_rpc_url()))
        receipt = w3.eth.get_transaction_receipt(tx_hash)
        for log in receipt["logs"]:
            if log_index is not None and int(log["logIndex"]) != log_index:
                continue
            decoded = decode_condition_preparation(log)
            if decoded:
                condition_data = decoded
                break

        if not condition_data:
            raise RuntimeError("ConditionPreparation log not found in transaction receipt.")

    condition_id = None
    question_id = None
    oracle = None
    outcome_slot_count = 2

    if condition_data:
        condition_id = condition_data.get("conditionId")
        question_id = condition_data.get("questionId")
        oracle = condition_data.get("oracle")
        outcome_slot_count = int(condition_data.get("outcomeSlotCount", 2))

    if gamma_data:
        condition_id = condition_id or gamma_data.get("conditionId")
        question_id = question_id or gamma_data.get("questionId")
        oracle = oracle or gamma_data.get("oracle")

    if not oracle:
        oracle = get_oracle_address()

    if not condition_id or not question_id:
        missing = [name for name, value in [("conditionId", condition_id), ("questionId", question_id)] if not value]
        raise RuntimeError(
            "Missing condition data (" + ", ".join(missing) + "). Provide --market-slug or a tx hash with ConditionPreparation log."
        )

    positions = derive_binary_positions(
        oracle=oracle,
        question_id=question_id,
        condition_id=condition_id,
        collateral_token=USDC_E,
    )

    payload: Dict[str, Any] = {
        "conditionId": condition_id,
        "oracle": Web3.to_checksum_address(oracle),
        "questionId": question_id,
        "outcomeSlotCount": outcome_slot_count,
        "collateralToken": USDC_E,
        "yesTokenId": positions.position_yes,
        "noTokenId": positions.position_no,
    }

    if gamma_data:
        payload["gamma"] = {
            "conditionId": gamma_data.get("conditionId"),
            "oracle": gamma_data.get("oracle"),
            "questionId": gamma_data.get("questionId"),
            "clobTokenIds": gamma_data.get("clobTokenIds"),
            "raw": gamma_data.get("raw"),
        }

    return payload


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Decode Polymarket market parameters.")
    parser.add_argument("--market-slug", help="Gamma API market slug")
    parser.add_argument("--tx-hash", help="Transaction hash with ConditionPreparation")
    parser.add_argument("--log-index", type=int, help="Log index of ConditionPreparation")
    parser.add_argument("--output", help="Write JSON output to a file")
    return parser.parse_args()


def main() -> None:
    args = _parse_args()
    payload = decode_market(tx_hash=args.tx_hash, log_index=args.log_index, market_slug=args.market_slug)

    if args.output:
        write_json(args.output, payload)
    else:
        print_json(payload)


if __name__ == "__main__":
    main()
```

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Any

from hexbytes import HexBytes
from web3 import Web3


@dataclass(frozen=True)
class BinaryPositions:
    collection_yes: str
    collection_no: str
    position_yes: str
    position_no: str


def _normalize_bytes32(value: Any) -> bytes:
    if isinstance(value, (bytes, bytearray, HexBytes)):
        data = bytes(value)
        if len(data) != 32:
            raise ValueError("Expected 32-byte value.")
        return data
    if isinstance(value, int):
        return value.to_bytes(32, byteorder="big")
    if isinstance(value, str):
        hex_value = value
        if not hex_value.startswith("0x"):
            hex_value = "0x" + hex_value
        data = Web3.to_bytes(hexstr=hex_value)
        if len(data) != 32:
            raise ValueError("Expected 32-byte hex string.")
        return data
    raise TypeError("Unsupported bytes32 value type.")


def derive_binary_positions(
    *,
    oracle: str,
    question_id: str,
    condition_id: str,
    collateral_token: str,
) -> BinaryPositions:
    w3 = Web3()
    parent_collection_id = _normalize_bytes32("0x" + "00" * 32)
    condition_id_bytes = _normalize_bytes32(condition_id)

    collection_yes = w3.solidity_keccak(
        ["bytes32", "bytes32", "uint256"],
        [parent_collection_id, condition_id_bytes, 1],
    ).hex()
    collection_no = w3.solidity_keccak(
        ["bytes32", "bytes32", "uint256"],
        [parent_collection_id, condition_id_bytes, 2],
    ).hex()

    position_yes = w3.solidity_keccak(
        ["address", "bytes32"],
        [Web3.to_checksum_address(collateral_token), _normalize_bytes32(collection_yes)],
    ).hex()
    position_no = w3.solidity_keccak(
        ["address", "bytes32"],
        [Web3.to_checksum_address(collateral_token), _normalize_bytes32(collection_no)],
    ).hex()

    return BinaryPositions(
        collection_yes=collection_yes,
        collection_no=collection_no,
        position_yes=position_yes,
        position_no=position_no,
    )
```

```python
from __future__ import annotations

from typing import Any, Dict, List, Optional

import requests

from src.config import get_gamma_api_url


def _get_json(path: str, params: Optional[Dict[str, str]] = None) -> Any:
    base_url = get_gamma_api_url().rstrip("/")
    url = f"{base_url}{path}"
    response = requests.get(url, params=params, timeout=30)
    response.raise_for_status()
    return response.json()


def fetch_event_by_slug(slug: str) -> Optional[Dict[str, Any]]:
    payload = _get_json("/events", params={"slug": slug})
    if isinstance(payload, list):
        return payload[0] if payload else None
    return payload


def fetch_market_by_slug(slug: str) -> Optional[Dict[str, Any]]:
    payload = _get_json("/markets", params={"slug": slug})
    if isinstance(payload, list):
        return payload[0] if payload else None
    return payload


def fetch_markets_for_event(event_id: str) -> List[Dict[str, Any]]:
    payload = _get_json("/markets", params={"event": event_id})
    if isinstance(payload, list):
        return payload
    return [payload]
```
