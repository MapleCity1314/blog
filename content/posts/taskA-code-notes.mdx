---
title: "任务 A 代码解读：Trade Decoder"
date: "2026-01-26"
description: "任务 A 源码逐段解读与关键函数说明。"
tags: ["Blog"]
published: true
---



# 任务 A 代码解读：Trade Decoder

本文件逐段解读任务 A 的代码实现，帮助快速理解每个函数在解码流程中的角色。

## 文件与结构

- `src/trade_decoder.py`：交易日志解码主文件。
- `src/utils.py`：数值与 JSON 输出辅助。

## 关键结构

### 常量与签名

- `EXCHANGE_ADDRESSES`：白名单交易合约地址，避免解析非 Polymarket 日志。
- `ORDER_FILLED_SIGNATURES`：两个 `OrderFilled` 事件签名，用于兼容不同 ABI 版本。

### 数据模型

- `Trade`：输出结构体，字段与验收要求保持一致。
- `_OrderFilledDecoded`：内部中间结构，便于统一计算与过滤。

### 日志解析

- `_topic_to_address`：从 topic 取出末 40 位作为地址。
- `_as_hex`：统一处理 HexBytes/bytes/str。
- `_decode_order_filled`：核心解析逻辑，三种路径：
  - `topics == 4`：`order_hash` 在 topic，`maker`/`taker` 也在 topic。
  - `topics == 3`：`maker`/`taker` 在 topic，`order_hash` 可能在 data。
  - 其他：全字段在 data（含 `order_hash` 与地址）。

### 交易方向与价格

- `_calculate_trade_fields`：
  - `maker_asset_id == 0` 表示 maker 支付 USDC，因此为 BUY。
  - `maker_asset_id != 0` 表示 maker 支付 Token，因此为 SELL。
  - 价格用 `Decimal` 计算后转为字符串。

### 交易过滤

- `decode_trades`：
  - 先过滤合约地址，再解码。
  - `normalize_address(decoded.taker) == exchange` 时跳过，避免 taker 汇总日志重复。

### CLI 与输出

- `_parse_args` 提供 `--tx-hash` 与 `--output`。
- `main` 负责把 `Trade` 转换为字典并打印或写文件。

## 关键路径串联

1. `main` → 解析参数 → 调用 `decode_trades`。
2. `decode_trades` → 拉回执 → 过滤合约 → `_decode_order_filled`。
3. `_decode_order_filled` → 生成 `_OrderFilledDecoded`。
4. `_calculate_trade_fields` → 计算 `price`/`token_id`/`side`。
5. 组装 `Trade` → JSON 输出。

## 可关注的细节

- `ORDER_FILLED_SIGNATURES` 中的两个签名分别对应 “含 orderHash” 与 “不含 orderHash” 的变体。
- `data_bytes` 的长度用于判断 ABI 结构，避免错误解码。
- 输出字段均为字符串，以避免大数精度丢失。


## Source Code (verbatim)

```python
from __future__ import annotations

import argparse
import json
from dataclasses import asdict, dataclass
from decimal import Decimal
from typing import Any, Dict, Iterable, List, Optional

from eth_abi import decode
from hexbytes import HexBytes
from web3 import Web3

from src.config import get_rpc_url
from src.utils import decimal_to_str, normalize_address, print_json, write_json


EXCHANGE_ADDRESSES = {
    "0x4bFb41d5B3570DeFd03C39a9A4D8dE6Bd8B8982E".lower(),
    "0xC5d563A36AE78145C45a50134d48A1215220f80a".lower(),
}

ORDER_FILLED_SIGNATURES = {
    Web3.keccak(text="OrderFilled(bytes32,address,address,uint256,uint256,uint256,uint256,uint256)").hex(),
    Web3.keccak(text="OrderFilled(address,address,uint256,uint256,uint256,uint256,uint256)").hex(),
}


@dataclass(frozen=True)
class Trade:
    tx_hash: str
    log_index: int
    exchange: str
    maker: str
    taker: str
    maker_asset_id: str
    taker_asset_id: str
    maker_amount: str
    taker_amount: str
    price: str
    token_id: str
    side: str


@dataclass(frozen=True)
class _OrderFilledDecoded:
    order_hash: Optional[str]
    maker: str
    taker: str
    maker_asset_id: int
    taker_asset_id: int
    maker_amount: int
    taker_amount: int
    fee: int


def _topic_to_address(topic: str) -> str:
    if topic.startswith("0x"):
        topic = topic[2:]
    return "0x" + topic[-40:]


def _as_hex(value: Any) -> str:
    if isinstance(value, HexBytes):
        return value.hex()
    return str(value)


def _decode_order_filled(log: Dict[str, Any]) -> Optional[_OrderFilledDecoded]:
    topics = [_as_hex(topic) for topic in log.get("topics", [])]
    if not topics:
        return None

    signature = topics[0]
    if signature not in ORDER_FILLED_SIGNATURES:
        return None

    data_hex = log.get("data", "0x")
    if isinstance(data_hex, (bytes, bytearray, HexBytes)):
        data_bytes = bytes(data_hex)
    else:
        data_bytes = bytes.fromhex(data_hex[2:]) if data_hex.startswith("0x") else bytes.fromhex(data_hex)

    order_hash = None
    maker = None
    taker = None
    values: Iterable[Any]

    if len(topics) == 4:
        order_hash = topics[1]
        maker = _topic_to_address(topics[2])
        taker = _topic_to_address(topics[3])
        values = decode(["uint256", "uint256", "uint256", "uint256", "uint256"], data_bytes)
    elif len(topics) == 3:
        maker = _topic_to_address(topics[1])
        taker = _topic_to_address(topics[2])
        if len(data_bytes) == 32 * 6:
            decoded = decode(["bytes32", "uint256", "uint256", "uint256", "uint256", "uint256"], data_bytes)
            order_hash = "0x" + decoded[0].hex()
            values = decoded[1:]
        else:
            values = decode(["uint256", "uint256", "uint256", "uint256", "uint256"], data_bytes)
    else:
        if len(data_bytes) == 32 * 8:
            decoded = decode(
                [
                    "bytes32",
                    "address",
                    "address",
                    "uint256",
                    "uint256",
                    "uint256",
                    "uint256",
                    "uint256",
                ],
                data_bytes,
            )
            order_hash = "0x" + decoded[0].hex()
            maker = decoded[1]
            taker = decoded[2]
            values = decoded[3:]
        else:
            return None

    maker_asset_id, taker_asset_id, maker_amount, taker_amount, fee = values
    return _OrderFilledDecoded(
        order_hash=order_hash,
        maker=Web3.to_checksum_address(maker),
        taker=Web3.to_checksum_address(taker),
        maker_asset_id=int(maker_asset_id),
        taker_asset_id=int(taker_asset_id),
        maker_amount=int(maker_amount),
        taker_amount=int(taker_amount),
        fee=int(fee),
    )


def _calculate_trade_fields(decoded: _OrderFilledDecoded) -> Dict[str, str]:
    maker_asset_id = decoded.maker_asset_id
    taker_asset_id = decoded.taker_asset_id
    maker_amount = Decimal(decoded.maker_amount)
    taker_amount = Decimal(decoded.taker_amount)

    if maker_asset_id == 0:
        price = maker_amount / taker_amount
        token_id = str(taker_asset_id)
        side = "BUY"
    else:
        price = taker_amount / maker_amount
        token_id = str(maker_asset_id)
        side = "SELL"

    return {
        "price": decimal_to_str(price),
        "token_id": token_id,
        "side": side,
    }


def decode_trades(tx_hash: str) -> List[Trade]:
    w3 = Web3(Web3.HTTPProvider(get_rpc_url()))
    receipt = w3.eth.get_transaction_receipt(tx_hash)

    trades: List[Trade] = []
    for log in receipt["logs"]:
        exchange = normalize_address(log["address"])
        if exchange not in EXCHANGE_ADDRESSES:
            continue

        decoded = _decode_order_filled(log)
        if not decoded:
            continue

        if normalize_address(decoded.taker) == exchange:
            continue

        computed = _calculate_trade_fields(decoded)
        trade = Trade(
            tx_hash=tx_hash,
            log_index=int(log["logIndex"]),
            exchange=Web3.to_checksum_address(exchange),
            maker=decoded.maker,
            taker=decoded.taker,
            maker_asset_id=str(decoded.maker_asset_id),
            taker_asset_id=str(decoded.taker_asset_id),
            maker_amount=str(decoded.maker_amount),
            taker_amount=str(decoded.taker_amount),
            price=computed["price"],
            token_id=computed["token_id"],
            side=computed["side"],
        )
        trades.append(trade)

    return trades


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Decode Polymarket OrderFilled logs from a tx hash.")
    parser.add_argument("--tx-hash", required=True, help="Transaction hash on Polygon")
    parser.add_argument("--output", help="Write JSON output to a file")
    return parser.parse_args()


def main() -> None:
    args = _parse_args()
    trades = decode_trades(args.tx_hash)
    payload = [asdict(trade) for trade in trades]

    if args.output:
        write_json(args.output, payload)
    else:
        print_json(payload)


if __name__ == "__main__":
    main()
```
